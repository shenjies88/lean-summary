# 读书笔记

## 第一章 介绍

### 存储分级

- 寄存器：CPU寄存器保存来自告诉缓存的存储器的字节
- L1高速缓存（SRAM）：保存L2的高速缓存行
- L2高速缓存（SRAM）：保存L3的高速缓存行
- L3高速缓存（SRAM）：保存主存的高速缓存行
- 主存（DRAM）：主存保存来自本地磁盘的磁盘快
- 本地二级存储：本地磁盘保存取自远程网络服务器上磁盘的文件
- 远程二际存储：Web服务器
- 越往上更小更快更贵

## 第二章 信息的表示和处理

### 十进制-二进制-十六进制转换

| 十进制 | 二进制    | 十六进制 | <<2       | >>2（逻辑） | >>2（算数） |
| ------ | --------- | -------- | --------- | ----------- | ----------- |
| 0      | 0000 0000 | 0x00     | 0000 0000 | 0000 0000   | 0000 0000   |
| 167    | 1010 0111 | 0xA7     | 1001 1110 | 0010 1001   | 1110 1001   |
| 188    | 1011 1100 | 0xBC     | 1111 0000 | 0010 1111   | 1110 1111   |

- 对机器来说，程序就是字节序列，`没有保存有原程序的意义`
- 系统对二进制字节序列的解析，数据类型的字长影响`移植性`

### 无符号数和有符号数的转换

- U->T

  ```java
  if (x <= Tmax) 
  result = x ;
   else 
  result = x-2^w;
  ```

- T->U

  ```java
  if( x < 0) 
  result = x + 2^w;
   else 
  result = x;
  ```

- 有无符号数转换为有符号数时会出现`负数`，有无符号数超过了有符号数的表示范围，要减去最高位的次方

### 位数扩充

- 无符号数在前面补0
- 有符号数在前面补1

### 用补码表示反码的原因

- 用例说明
  https://www.douban.com/note/223507364/

- > 为了把减法换成加法

- 减去一个数，等于加上这个数的补数

- 人类理解的补数求法：`模`-`该数绝对值`

- 计算补数求法：`求反+1`

- 下列例子论证：

  ```
  四位数模等于二进制1 0000 十进制16
  求十进制数5的补数，二进制表示为 0101
   1 0000
  -  0101
  ————————
     1011
     
     0111 7
   + 1011 
   ————————
   1 0010
   
   去掉最高位等于2，即7-5 = 7 + 11 ，模16
   
    1 0000 - 0101
   = ( 1111 + 1 ) - 0101
   = ( 1111 - 0101 ） +1
   反码公式推理
  ```

### 浮点数表示

> https://blog.csdn.net/boatalways/article/details/17121205

### 舍入

- 采用偶数舍入的方式，避免统计偏差

### 整数乘除法实现

- > https://blog.csdn.net/zdavb/article/details/47108505

## 第三章 程序的机器级表示

### 数据类型声明

| C声明  | Interl数据类型 | 汇编代码后缀 | 大小（字节） |
| ------ | -------------- | ------------ | ------------ |
| char   | 字节           | b            | 1            |
| short  | 字             | w            | 2            |
| int    | 双字           | l            | 4            |
| long   | 四字           | q            | 8            |
| char*  | 四字           | q            | 8            |
| float  | 单精度         | s            | 4            |
| double | 双精度         | l            | 8            |

### 条件码

- CF：进位，最近的操作使高位产生了进位，检查无符号溢出
- ZF：零标志，最近的操作得出的结果为0
- SF：符号标志，最近的操作得到的结果为负数
- OF：溢出标志，最近的一个操作导致补码溢出-----正溢出或负溢出

### 比较指令

只设置条件码，不改变寄存器

- 比较无符号数时，依赖 CF和ZF标志
- 比较有符号数时，依赖SF和OF标志

### 过程

- 调用函数时传递6个参数以内，把参数放到相应的寄存器
- 7到n个参数，存放到栈的`参数构造区`
- P过程如果要调用Q过程，需要把`被调用者寄存器`里的值进行保存，保证回到P的时候和原来一样，通过栈顶保存
  - 做法1：P在自己的栈帧中保存
  - 做法2：Q如果要使用`被调用者寄存器`要先将值进行保存，返回时将值复原

### 防止数组越界操作

- 栈随机化
- 在栈中放置`金丝雀`值，程序返回时判断该值是否更变，更变则报出异常
- 限制可执行的内存区域，只有保存编译期生成程序的内存才是可执行的

## 第四章 处理器

### 指令分阶段处理

- 取值
  - icode指令代码
  - ifun指令功能
  - ra和rb
  - valC：四字常数字
  - valP：等于PC+已取出的指令长度
- 译码
  - 从寄存器文件读入做多两个操作数，得到valA和/或valB
  - 通常读入rA和rB字段知名的寄存器，有些指令读%rsp
- 执行
  - valE：计算/逻辑单元（ALU）要么执行指令知名的操作（根据ifun的值）或计算内存引用的有效地址，要么增加或减少栈指针。
  - 也可能设置条件码
- 访存
  - valM：访存阶段可以将数据写入内存，或者从内存读出数据。
- 写回
  - 最多可以写两个结果到寄存器文件
- 更新
  - 将PC设置成吓一跳指令的地址

### 数据冒险

- 下一条指令需要上一条直接产生的结果，两条指在相邻位置会产生数据冒险，即上一条指令并没有达到写回阶段
  - 暂停指令，在指令中插入`冒泡`
  - 数据转发

## 第五章 优化程序性能

### 总结网站

### 处理器工作

- 处理器会提前很多时间对指令进行译码和预测

### 循环优化

- 把循环条件移除循环体，减少了函数调用

  ```java
  int len = list.size();
  for(int i = 0 ; i < len ; i++);
  ```

### 消除不必要的内存引用

- 参数是在寄存器中的，定义临时变量能消除内存引用

```java
int ret;
int temp = 1;
int len = list.size();
for(int i = 0 ; i < len ; i++) {
    temp += list.get(i);
}
ret = temp;
```

### 循环展开

- 可以一次性计算`i`和`i+1`的值，减少了预测分支结果的次数

### 提高并行性

- 可以定义两个临时变量来计算`i`和`i+1`的值

### 交换操作数位置

- 因为d[]是在一个寄存器内的，所以`d[i]`+`d[i+1]`的计算不需要等待

```
dest + (d[i] + d[i+1])
```

### 尽量使用条件传送，而不是条件跳转

## 第六章 存储器层次结构

### 处理器和内存之间的存取

- 通过总线来读取和存储

### 磁盘概念

- 盘面上有磁道
- 磁道的周长被分为多个扇区，扇区中存储位，间隙中不存储
- 柱面是所有盘面表面上到株洲中心的距离相等的磁道的集合

### 对扇区访问时间

- 寻道时间：为了定位目标扇区的磁道，移动传动比的时间
- 旋转时间：定位到了期望磁道，等待目标扇区第一个位旋转到的时间
- 传送时间：目标扇区第一个位位于读写投下时，开始读写，依赖寻找速度和每条磁道的扇区数目、
- 主要的耗费点是寻道时间

### 局部性

- 重复引用一个变量，具有`时间局部性`
- 在循环中步长为k，k越小越好，具有`空间局部性`

## 第七章 连接

### 编译程序

- 将代码翻译成ASCII码中间文件i
- 将文件i翻译成ASCII码汇编文件s
- 将文件s转换为可重定位目标文件o
- 链接器将文件o链接起来生成可执行文件

### 链接

- 将不同的C文件编译链接起来成为一个可执行的文件
- 采用符号引用来维护全局变量和函数地址

### 链接时数据的选择

- 优先选择已初始化的数据

### 位置无关代码（PIC）

- 维护一个共享数据的全局偏移量表，该思想是该表是运行时常量

### 共享库函数调用

- 延迟绑定，在第一次调用该函数的时候绑定该地址

## 第八章  异常

### 进程

- 执行中程序的实例，系统中的每个程序都运行在某个进程的上下文中

### 内核

- 系统在内存中的地址，用户不可见
- 用户通过系统函数访问内核

## 第九章 虚拟内存

### 概念

- 对主存的抽象，CPU产生虚拟地址，虚拟地址通过翻译之后再去访问物理地址

## 第十章 系统级I/O

### 概念

- 文件在系统中是二进制序列的抽象

## 第十一章 网络编程

## 第十二章 并发编程