## 一些理论

### shell语言特性

- 解释性语言

### 脚本无法改变环境变量

- 因为shell脚本在执行命令时是通过fork()系统调用创建子进程去执行
- 子进程无法改变父进程的环境变量
- 如果不希望脚本创建子进程，可以使用 `source`命令+可执行文件

## Hello World

```shell
#! /bin/sh
echo "Hello World"
```

## 变量

- export
  - 把变量设置为环境变量，新的子shell都能访问

```shell
#! /bin/sh
MES="Hello World"
echo ${MES}
```

## 循环

```shell
#!/bin/sh
for i in 1 2 3 4 5
do
  echo "Looping ... number $i"
done
```

```shell
#!/bin/sh
INPUT_STRING=hello
while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something in (bye to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
```

```shell
#!/bin/sh
while :
do
  echo "Please type something in (^C to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
```

## 测试

```shell
#! /bin/sh
if [ ... ]
then
  # if-code
else
  # else-code
fi
```

## CASE

```shell
#!/bin/sh

echo "Please talk to me ..."
while :
do
  read INPUT_STRING
  case $INPUT_STRING in
	hello)
		echo "Hello yourself!"
		;;
	bye)
		echo "See you again!"
		break
		;;
	*)
		echo "Sorry, I don't understand"
		;;
  esac
done
echo 
echo "That's all folks!"
```

## 内置变量

- $0 执行程序的文件名
- $1-$9传入的参数
- $@所有参数 $*但不包括空格和引号，推荐使用$@
- $#参数的数量

## 函数

```shell
#!/bin/sh
# A simple script with a function...

add_a_user()
{
  USER=$1
  PASSWORD=$2
  shift; shift;
  # Having shifted twice, the rest is now comments ...
  COMMENTS=$@
  echo "Adding user $USER ..."
  echo useradd -c "$COMMENTS" $USER
  echo passwd $USER $PASSWORD
  echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
}

###
# Main body of script starts here
###
echo "Start of script..."
add_a_user bob letmein Bob Holness the presenter
add_a_user fred badpassword Fred Durst the singer
add_a_user bilko worsepassword Sgt. Bilko the role model
echo "End of script..."
```

## sed

### 编辑文本流

- 不会修改原文件，如需修改 > 重定向
- -e 根据表达式操作
- -n 显示操作的行
- -f 执行脚本

### 实例

```shell
  sed -n -e '1，5d' file
```

删除文件的第一到第五行，并且把删除的行显示出来

  ```shell
  sed -e -n '/正则/p' file
  ```

  打印和`/正则表达式/`匹配的行

```shell

```

