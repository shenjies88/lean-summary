## 一些理论

### shell语言特性

- 解释性语言

### 脚本无法改变环境变量

- 因为shell脚本在执行命令时是通过`fork()`系统调用创建子进程去执行
- 子进程无法改变父进程的环境变量
- 如果不希望脚本创建子进程，可以使用 `source`命令+可执行文件

## Hello World

```shell
#! /bin/sh
echo "Hello World"
```

## 变量

- export
  - 把变量设置为环境变量，新的子shell都能访问
- 变量和值间无空格

```shell
#! /bin/sh
MES="Hello World"
MES=@(命令过滤)
echo ${MES}
```

## 循环

```shell
#!/bin/sh
for i in 1 2 3 4 5
do
  echo "Looping ... number $i"
done
```

```shell
#!/bin/sh
INPUT_STRING=hello
while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something in (bye to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
```

```shell
#!/bin/sh
while :
do
  echo "Please type something in (^C to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
```

## 测试

```shell
#! /bin/sh
if [ ... ]
then
  # if-code
else
  # else-code
fi
```

## CASE

```shell
#!/bin/sh

echo "Please talk to me ..."
while :
do
  read INPUT_STRING
  case $INPUT_STRING in
	hello)
		echo "Hello yourself!"
		;;
	bye)
		echo "See you again!"
		break
		;;
	*)
		echo "Sorry, I don't understand"
		;;
  esac
done
echo 
echo "That's all folks!"
```

## 内置变量

- `$0` 执行程序的文件名
- `$1-$9`是传入的参数
- `${10}`第十个以上的参数s
- `$@`所有参数` $*`但不包括空格和引号，推荐使用`$@`
- `$#`参数的数量

## 函数

```shell
#!/bin/sh
# A simple script with a function...

add_a_user()
{
  USER=$1
  PASSWORD=$2
  shift; shift;
  # Having shifted twice, the rest is now comments ...
  COMMENTS=$@
  echo "Adding user $USER ..."
  echo useradd -c "$COMMENTS" $USER
  echo passwd $USER $PASSWORD
  echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
}

###
# Main body of script starts here
###
echo "Start of script..."
add_a_user bob letmein Bob Holness the presenter
add_a_user fred badpassword Fred Durst the singer
add_a_user bilko worsepassword Sgt. Bilko the role model
echo "End of script..."
```

## sed

### 编辑文本流

- 不会修改原文件，如需修改 > 重定向
- `-e` 根据表达式操作
- `-n` 显示操作的行
- `-f` 执行脚本

### 实例

```shell
  sed -n -e '1，5d' file
```

- 删除文件的第一到第五行，并且把删除的行显示出来

```
sed -e -n '/正则/p' file
```

- 打印和`正则表达式`匹配的行

```shell
sed -e 's/aaa/bbb/g' file
```

- 把文件中的`aaa`替换成`bbb` `/g`表示全局替换

```shell
sed -e '/BEGIN/,/END/p' file
```

- 打印正则`BEGIN`到`END`范围的文本，匹配了`BEGIN`但是没有匹配`END`一样会输出，但是没有匹配`BEGIN`则不会输出

## awk

### 过滤输出

- 不会修改原文件
- `-F`重设分隔符，默认是`空格`，可以设置为`正则`
- `-f`执行脚本

### 实例

```shell
awk '{print $1 $3}' file
```

- 打印文件的第一列和第三列

```shell
awk -F":" '{print $1 $3}' file
```

- 以-F标记的分隔符，打印第一列和第三列

```shell
awk '{print " user : "$1" name : "$2"  "}'
```

- 想在输入时插入一些东西需要用`""`扩起来，变量也需要用`""`扩起来

```shell
BEGIN {
    print "How many people with nologin"
}
/nologin/ {adder++}
END {
    print "'nologin' appears " adder " times "
}
```

```shell
awk -f count.awk file
```

- 使用脚本，对该文件里面的`nologin`进行计数，`//`内填写正则表达式，后续的`{}`内填写逻辑

```shell
awk -F":" '/正则/{print $0}'
```

- 根据`正则`输出行

```shell
awk 'BEGIN{print ENVIRON["HOME"];print ENVIRON["PATH"]}'
```

- 打印环境变量

```shell
awk '{print "3+2=" 3+2}'
```

- 计算

- 判断和循环类似于`C语言`不提供实例

- 内置变量
  - FS 以什么样的字符来区分一个字段
  - RS 以什么样的字符来区分一个记录
  - OFS 字段之间插入的字符
  - ORS 记录之间插入的字符
  - NR已经读出的记录
  - FNR当前记录数
  - NF当前处理记录的字段数